#pragma config(Hubs,  S1, HTServo,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S3,     HTGYRO,         sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     HTSPB,          sensorI2CCustom9V)
#pragma config(Motor,  mtr_S1_C2_1,     rightA,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     leftA,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     leftB,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     rightB,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     liftLeft,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     liftRight,     tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C1_1,    ballDump,             tServoStandard)
#pragma config(Servo,  srvo_S1_C1_2,    grabOne,              tServoStandard)
#pragma config(Servo,  srvo_S1_C1_3,    grabTwo,              tServoStandard)
#pragma config(Servo,  srvo_S1_C1_4,    servoTurret,          tServoStandard)
#pragma config(Servo,  srvo_S1_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//** Team 7890: Space Lions
//** Horace Mann School, Bronx, NY
//** Version:
//** Tournament Iteration:

//** Authors: Nick Keirstead, Jacob Hoglund, Joshua Gruenstein

//Goal of Program:

#define TICK_RATIO_LEFT 130 //ticks per 1 inch traveled left side
#define TICK_RATIO_RIGHT 135 //ticks per 1 inch traveled right side
#define TICK_DEGREE_RATIO 21
#define BALL_DUMP_DOWN 50
#define BALL_DUMP_UP 256
#define GRABBERS_UP 5
#define GRABBERS_DOWN 222
#define DRIVE_PACE 100

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "prodrive.h" //Include library for rangefinder
#include "menu_helper.h" // Include libraries for pre-autonomous delay setting
#include "menu_setup.h"

void initializeRobot()
{
	servo[grabOne] = servo[grabTwo] = 0;
	servo[servoTurret] = 128;
	servoChangeRate[ballDump] = 7;
}

////****************************
////  DRIVE FUNCTIONS SECTION

void setMotor (tMotor arbMotor, int power) {
	motor[arbMotor] = power;
}

void encoderReset () {
	nMotorEncoder[rightA] = 0;
	nMotorEncoder[leftA] = 0;
	nMotorEncoder[rightB] = 0;
	nMotorEncoder[leftB] = 0;
}

void powerSide (int dir, int power) {
	if (dir == 0) {
		setMotor(leftA,power);
		setMotor(leftB,power);
	}
	else if (dir == 1) {
		setMotor(rightA,power);
		setMotor(rightB,power);
	}
}

void drive (int leftPow, int rightPow) {
	powerSide(0,leftPow);
	powerSide(1,rightPow);
}

void straightDrive (int power) {
	drive(power, power);
}

void halt () {
	straightDrive(0);
}

void grabbersUp () {
	servo[grabOne] = servo[grabTwo] = GRABBERS_UP;//deploy grabbers
	wait1Msec(500);
}

void grabbersDown () {
	servo[grabOne] = servo[grabTwo] = GRABBERS_DOWN;//deploy grabbers
	wait1Msec(500);
}

/*void oldPivot (int dir,int power, int deg) {
	int target = TICK_DEGREE_RATIO * deg;

	encoderReset();
	while (nMotorEncoder[leftB] < target && nMotorEncoder[rightB] < target) {
		if (dir == 0) {
			drive(-power,power);
		}
		else if (dir == 1) {
			drive(power,-power);
		}
		else {
			break;
		}
	}
	halt();
}*/

void pivot (int direction, int power, float deg) {
	float heading = 0;
	float angle = deg;
	int delay = 20;
	wait1Msec(250);

	int offset = SensorValue(HTGYRO);

	if (direction == 1) {
		while (abs(heading) < abs(angle)) {
			heading += (SensorValue(HTGYRO) - offset) * (float)(delay / 1000.0);
			powerSide(0,power);
			powerSide(1,-power);
			wait1Msec(delay);
		}
	}
	else {
		while (abs(heading) < abs(angle)) {
		heading += (SensorValue(HTGYRO) - offset) * (float)(delay / 1000.0);
			powerSide(0,-power);
			powerSide(1,power);
			wait1Msec(delay);
		}
	}
	halt();
}

void driveDistance (int power,int inches) { encoderReset();
	int tickGoalL = abs(inches*TICK_RATIO_LEFT);
	int tickGoalR = abs(inches*TICK_RATIO_RIGHT);

	while (abs(nMotorEncoder[leftB]) < tickGoalL && abs(nMotorEncoder[rightB]) < tickGoalR) {
			straightDrive(power * sgn(inches));
	}
	halt();
}
/////*************************
///// GAME FUNCTIONS SECTION

int readSonar (int numReads) {
	int inputdata;

  // Set B0 for output
  HTSPBsetupIO(HTSPB, 0x1);

  // Read a 10bit wide analogue value from A0
  inputdata = 0;
	for (int i=0; i< numReads; i++) {
  	inputdata += HTSPBreadADC(HTSPB, 0, 10);
  	wait1Msec(5);
	}
	inputdata /= numReads;
	return inputdata;
  // If A0 is less than 50% of the max value
  // turn off the LED, otherwise switch it on
}

int sonarTurretPosition (int servoPos, int numReads) {
	servo[servoTurret] = servoPos;
	wait1Msec(100);
	int sonarVal = readsonar(numReads);
	return sonarVal;
}

void downRamp () {
	driveDistance(DRIVE_PACE,-80);
	wait1Msec(50);
	driveDistance(DRIVE_PACE*2/3,-20);
}

/*void dumpBall () {

}*/

void correctApproach (bool firstTube) {
	if (firstTube) {
		pivot(1,DRIVE_PACE,15);
		wait1Msec(50);
		driveDistance(DRIVE_PACE/2,-15);
		wait1Msec(50);
		pivot(0,DRIVE_PACE,15);
		wait1Msec(50);
	}
	else {
		pivot(1,DRIVE_PACE,15);
	}
}

void grabTube (int attemptNum, bool firstTube) {
	servo[grabOne] = servo[grabTwo] = 0;
	wait1Msec(500);
	if (attemptNum > 0) {
		if (attemptNum == 1 && firstTube) correctApproach(true);//turn robot to align better
		else if (attemptNum == 1 || attemptNum == 2) correctApproach(false);
		wait1Msec(50);
		driveDistance(DRIVE_PACE/2,-23);//reapproach tube--> drive slightly farther
	}
	wait1Msec(50);
	grabbersDown();
	wait1Msec(500);
	if (attemptNum > 0) driveDistance(DRIVE_PACE,23);
	else driveDistance(DRIVE_PACE,20);
}

bool haveTube (int turretPos) {
	int distanceFromTube = sonarTurretPosition(turretPos,50);
	if (distanceFromTube > 140) {
		return false;
	}
	else {
		return true;
	}
}

void haulOtherTube (int angle) {
	if (angle != 0) {
		pivot(1,DRIVE_PACE,angle);
	}
	driveDistance(100,130);
}

void getOtherTube () {
	int tryNum = 0;
	int angle = 0;
	driveDistance(DRIVE_PACE,20);
	wait1Msec(100);
	pivot(0,DRIVE_PACE/4,169);
	wait1Msec(50);
	driveDistance(DRIVE_PACE,-115);
	wait1Msec(500);
	grabTube(tryNum,false);
	wait1Msec(50);
	if (haveTube(180)) {
		haulOtherTube(angle);
	}
	else {
		angle+=5;
		do {
			tryNum++;
			grabTube(tryNum,false); //if tube not with robot, retreat and try again.
		}
		while (!haveTube(180));
		wait1Msec(500);
		haulOtherTube(angle);
	}
}

void haulTube(int turnAngle) {
	pivot(1,DRIVE_PACE/2,turnAngle);
	wait1Msec(50);
	driveDistance(DRIVE_PACE,45);
	wait1Msec(100);
 	pivot(1,DRIVE_PACE/2,(180-turnAngle));
  wait1Msec(100);
  grabbersUp();
 	driveDistance(DRIVE_PACE,-45);
	wait1Msec(100);
 	getOtherTube();
}

void getFirstTube () {
	int attemptNum = 0;
	int turnAngle = 35;
	downRamp();
	wait1Msec(100);
	//dumpBall();
	//wait1Msec(100);
	grabTube(attemptNum,true);
	wait1Msec(100);
	if (haveTube(180)) {
		haulTube(turnAngle);
	}
	else {
		turnAngle -= 3; //if must try again, smaller bearing angle --> won't hit center structure
		do {
			attemptNum++;
			grabTube(attemptNum,true); //if tube not with robot, retreat and try again.
		}
		while (!haveTube(180));
		wait1Msec(100);
		haulTube(turnAngle);
	}
}

void cascadeEffect (int secsDelay) {
	wait1Msec(secsDelay * 1000);
	getFirstTube();
}



////**************
//// TASKS SECTION

task main() {
	initializeRobot();
	setupMenu();
	bDisplayDiagnostics = false; //clear brick of normal diagnostics text
	startTask(runMenu);
	//wait1Msec(5000); //switch out for wait for start in competition
	waitForStart(); // Wait for the beginning of autonomous phase.

	stopTask(runMenu); //stop running selector menu
	eraseDisplay(); //clear brick
	bDisplayDiagnostics = true;//display normal diagnostics again

	cascadeEffect(delayTime);//run autonomous with inputted delay

}



////******************
//// NOTES SECTION

// Wheel diameter = 3 in
// Wheel circumference = 3 * pi = 9.425
// distance traveled = wheel rotations * circumference
// 									 = (degrees turned/360) * circumference
// 									 = (encoder ticks/360) * circumference
// --> encoder ticks = (360/circumference) * distance
