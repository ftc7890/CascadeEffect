#pragma config(Hubs,  S1, HTServo,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     HTGYRO,         sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     HTSPB,          sensorI2CCustom9V)
#pragma config(Motor,  mtr_S1_C2_1,     rightA,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     leftA,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     leftB,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     rightB,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     liftLeft,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     liftRight,     tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C1_1,    ballDump,             tServoStandard)
#pragma config(Servo,  srvo_S1_C1_2,    grabOne,              tServoStandard)
#pragma config(Servo,  srvo_S1_C1_3,    grabTwo,              tServoStandard)
#pragma config(Servo,  srvo_S1_C1_4,    servoTurret,          tServoStandard)
#pragma config(Servo,  srvo_S1_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//** Team 7890: Space Lions
//** Horace Mann School, Bronx, NY
//** Version:
//** Tournament Use:
//** Authors: Nick Keirstead, Jacob Hoglund, Joshua Gruenstein

//Goal of Program:


#define TICK_RATIO_LEFT 130 //ticks per 1 inch traveled left side
#define TICK_RATIO_RIGHT 135 //ticks per 1 inch traveled right side
#define TICK_DEGREE_RATIO 21
#define BALL_DUMP_DOWN 256
#define BALL_DUMP_UP 90
#define GRABBERS_UP 5
#define GRABBERS_DOWN 220

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "prodrive.h" //Include function library for rangefinder
#include "hitechnic-gyro.h" //Include library for gyroscope
#include "menu_helper.h" // Include libraries to enable pre-autonomous delay setting
#include "menu_setup.h"

void initializeRobot()
{
	servo[ballDump] = BALL_DUMP_DOWN; //lower ball dumper arm
	servo[grabOne] = servo[grabTwo] = GRABBERS_UP; //raise tube grabbers
	servo[servoTurret] = 128; //point custom rangefinder forward
}

////****************************
////  BUILDER FUNCTIONS SECTION

void setMotor (tMotor arbMotor, int power) {
	motor[arbMotor] = power;
}

void encoderReset () {
		nMotorEncoder[rightA] = 0;
		nMotorEncoder[leftA] = 0;
		nMotorEncoder[rightB] = 0;
		nMotorEncoder[leftB] = 0;
}

void powerSide (int dir, int power) {
	if (dir == 0) {
		setMotor(leftA,power);
		setMotor(leftB,power);
}
	else if (dir == 1) {
		setMotor(rightA,power);
		setMotor(rightB,power);
}
}

void drive (int leftPow, int rightPow) {
		powerSide(0,leftPow);
		powerSide(1,rightPow);
}

void straightDrive (int power) {
		drive(power, power);
}

void halt () {
	straightDrive(0);
}

//void oldPivot (int dir,int power, int deg) {
//	int target = TICK_DEGREE_RATIO * deg;

//	encoderReset();
//	while (abs(nMotorEncoder[leftB]) < target && abs(nMotorEncoder[rightB]) < target) {
//		if (dir == 0) {
//			drive(-power,power);
//		}
//		else if (dir == 1) {
//			drive(power,-power);
//		}
//		else {
//			break;
//		}
//	}
//	halt();
//}

void pivot (int direction, int power, int deg) {
	float heading = 0;
	float angle = deg * 1.00;
	int delay = 20;
	wait1Msec(250);

	if (direction == 1) {
		while (abs(heading) < abs(angle)) {
			heading += HTGYROreadRot(HTGYRO) * (float)(delay / 1000.0);
			powerSide(0,power);
			powerSide(1,-power);
			wait1Msec(delay);
		}
	}
	else {
		while (abs(heading) < abs(angle)) {
		heading += HTGYROreadRot(HTGYRO) * (float)(delay / 1000.0);
			powerSide(0,-power);
			powerSide(1,power);
			wait1Msec(delay);
		}
	}
	halt();
}

void driveDistance (int power,int inches) {

	int tickGoalL = abs(inches*TICK_RATIO_LEFT);
	int tickGoalR = abs(inches*TICK_RATIO_RIGHT);

	encoderReset();
	while (abs(nMotorEncoder[leftB]) < tickGoalL && abs(nMotorEncoder[rightB]) < tickGoalR) {
			straightDrive(power * sgn(inches));
	}
	halt();
}

int readSonar (int numReads) {
	int inputdata;

  // Set B0 for output
  HTSPBsetupIO(HTSPB, 0x1);

  // Read a 10bit wide analogue value from A0
  inputdata = 0;
	for (int i=0; i< numReads; i++) {
  	inputdata += HTSPBreadADC(HTSPB, 0, 10);
  	wait1Msec(5);
	}
	inputdata /= numReads;
	return inputdata;
  // If A0 is less than 50% of the max value
  // turn off the LED, otherwise switch it on
}

int findOrientation () {//determines center goal position from rangefinder readings
	int position;
	int reading = readSonar(100);

	if (reading < 340) position = 3;
	else if (reading < 450) position = 1;
	else position = 2;

	return position;
}

void raiseLifter () {
	setMotor(liftLeft,100);
	setMotor(liftRight,100);
	wait1Msec(1200);
	setMotor(liftLeft,0);
	setMotor(liftRight,0);
}

void lowerLifter () {
	setMotor(liftLeft,-100);
	setMotor(liftRight,-100);
	wait1Msec(1200);
	setMotor(liftLeft,0);
	setMotor(liftRight,0);
}

void dumperUp () {
	servo[ballDump] = BALL_DUMP_UP;
	wait1Msec(1000);
}

void dumperDown () {
	servoChangeRate[ballDump] = 2;
	servo[ballDump] = BALL_DUMP_DOWN;
	wait1Msec(1000);
	servoChangeRate[ballDump] = 10;
}

void knockStand (int position, bool kickstand) {//enact position-specific autonomous
	switch (position) {
		case 1:
			driveDistance(-30,43);
			wait1Msec(100);
			pivot(1,-20,65);
			wait1Msec(100);
			driveDistance(-100,25);
			wait1Msec(1000);
			break;
		case 2:
			driveDistance(-10,20);
			wait1Msec(100);
			pivot(1,20,90);
			wait1Msec(100);
			driveDistance(10,30);
			wait1Msec(100);
			pivot(1,30,80);
			wait1Msec(100);
			driveDistance(-10,10);
			wait1Msec(100);
			raiseLifter();
			wait1Msec(100);
			driveDistance(10,14);


			dumperUp();
			wait1Msec(1000);
			dumperDown();
			wait1Msec(500);
			driveDistance(-10,15);
			wait1Msec(100);
			dumperUp();
			wait1Msec(1000);
			lowerLifter();
			dumperDown();

			if (kickstand) {
				wait1Msec(100);
				pivot(1,35,40);
				driveDistance(30,30);
				pivot(0,35,70);
				driveDistance(100,50);

			}

			//driveDistance(-30,40);
			//wait1Msec(100);
			//pivot(0,-20,28);
			//wait1Msec(100);
			//driveDistance(-100,30);
			break;
		case 3:
			driveDistance(-30,25);
			wait1Msec(100);
			pivot(0,10,245);
			wait1Msec(100);
			raiseLifter();
			wait1Msec(1000);
			driveDistance(10,4);
			wait1Msec(500);
			dumperUp();
			wait1Msec(1000);
			dumperDown();
			wait1Msec(500);
			driveDistance(-10,5);
			wait1Msec(100);
			dumperUp();
			wait1Msec(1000);
			lowerLifter();
			dumperDown();

			if (kickstand) {
				wait1Msec(100);
				pivot(1,15,175);
				driveDistance(-100,30);
				pivot(0,20,10);
				driveDistance(-100,50);
			}



			/*pivot(1,20,32);
			wait1Msec(100);
			driveDistance(-30,20);
			wait1Msec(100);
			pivot(0,20,32);
			wait1Msec(100);
			driveDistance(-100,30);
			wait1Msec(100);
			driveDistance(-100,10);*/
	}
}

task main () {
	  initializeRobot();
		setupMenu();
		bDisplayDiagnostics = false; //clear brick of normal diagnostics text
		startTask(runMenu);
		//wait1Msec(5000);
		waitForStart(); // Wait for the beginning of autonomous phase.

		stopTask(runMenu); //stop running selector menu
		eraseDisplay(); //clear brick
		bDisplayDiagnostics = true;//display normal diagnostics again

		wait1Msec(delayTime * 1000);//wait however many seconds delay set to be

		int position = findOrientation();
	  //int reading = readSonar(100);
		nxtDisplayTextLine(2, "POS: %d", position);
		//nxtDisplayTextLine(2,"Read: %d",reading);
		wait1Msec(1500);
		knockStand(position,kickstand);


	  //dumperUp();
	  //wait1Msec(500);
	  //lowerLifter();
	  //wait1Msec(1000);
	  //raiseLifter();

}

////******************
//// NOTES SECTION

//library "prodrive.h" credit:
//	author Gustav Jansson (gus_at_hitechnic.com)
// 	date 10 October 2011
// 	version 0.1
